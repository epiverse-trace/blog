{
  "hash": "f2459b7700392b35efc1200d870ee1f1",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Using benchmarking to guide the adoption of dependencies in R packages\"\nsubtitle: \"An example with cli\"\nauthor:\n  - name: \"James Mba Azam\"\n    orcid: \"https://orcid.org/0000-0001-5782-7330\"\ndate: \"2023-11-22\"\ncategories: [benchmarking, R, cli, R package, software architecture]\nbibliography: index.bib\nformat:\n  html:\n    toc: true\nexecute: \n  cache: true\n---\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(bench)\nlibrary(cli)\nlibrary(dplyr)\nlibrary(ggplot2)\n```\n:::\n\n\nR package developers often have to take on dependencies for various reasons.\nDependencies are external packages that provide extra functionalities or\nfeatures to another package [@wickham2023r]. Quite often, the goal of taking\non a dependency is to utilize its rich features and reduce duplicated coding\neffort. For example, the `ggplot2` package is often adopted, instead of R's\ninbuilt plotting functions, to make visualizations using its declarative\nsystem and implementation of the Grammar of Graphics, and slick automation\nacross the board.\n\nSometimes, introducing a dependency might slow down existing processes. Hence,\nit is important to consider the speed of a dependency's functions before\nadopting it. Code optimisation is often reserved for heavy processes like data\nprocessing steps. However, here, we will focus on lesser optimised processes,\nand in particular, printing of texts in R.\n\nFor this demonstration, we will look at a situation where a package developer\nis considering options for condition signalling beyond the functionalities\nprovided in base R. Condition signalling refers to the process of communicating\nto a user that an issue has arisen during code execution [@wickham2019advanced].\n\nBase R ships with functionalities for condition signalling. There is\n`base::stop()` for signalling errors.  Errors refer to cases where something fatal\nhappens during code execution so that it halts, for example, when a function is\nrun without specifying the required arguments.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrnorm()\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in rnorm(): argument \"n\" is missing, with no default\n```\n\n\n:::\n:::\n\n\nBase R provides `base::warning()` for throwing warnings. Warnings are used to\nhandle less fatal issues with code execution that do not\nneed to halt the process. For example, when you compare two vectors of\ndifferent lengths, R will throw a warning but will still return a result.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1:2) > c(1:3)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in c(1:2) > c(1:3): longer object length is not a multiple of shorter\nobject length\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE FALSE FALSE\n```\n\n\n:::\n:::\n\n\nLastly, there is `base::message()` for throwing messages. Messages are used\nto provide useful information about processes. For example, packages throw\nmessages about NAMESPACE conflicts when loaded. This is to inform the user so\nthey know what next steps to take.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(data.table)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'data.table'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe following objects are masked from 'package:dplyr':\n\n    between, first, last\n```\n\n\n:::\n:::\n\n\nThese base R functions are, however, not flexible enough for advanced\nformatting: colour, progress bar, contextual pluralisation, and so forth.\nThe package developer might want to adopt external dependencies for these\nflexibilities. The [cli](https://cli.r-lib.org/articles/semantic-cli.html)\npackage is well designed for this. `cli` offers many of the advanced formatting\nfeatures. Here is a quick example (adopted from the help file) using\n`cli::cli_abort()`, the equivalent of `base::stop()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- \"c(1, 2, 3)\"\ncli_abort(\n    c(\n      \"{.var n} must be a numeric vector\",\n      \"x\" = \"You've supplied a {.cls {class(n)}} vector.\"\n    )\n)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError:\n! `n` must be a numeric vector\nâœ– You've supplied a <character> vector.\n```\n\n\n:::\n:::\n\n\nIn this example, we used inline text formatting to print `n` as a variable\nand interpolated code to print the class of `n` in the error message and all in\njust 6 lines of code.\n\nIf this is enough to excite your interests, check out `cli`'s [website](https://cli.r-lib.org/)\nand help files, which provide in-depth guides on its myriad features.\n\nNow, considering all these amazing features that `cli` offers, what should a\npackage developer consider to adopt it? In this article, we will\ndemonstrate how to use (micro)benchmarking[^1] to guide the decision through\nthe lense of speed. Benchmarking can be used to check whether\nadopting `cli` as a dependency would slow down existing printing\nprocesses in undesirable ways.\n\nHere, we will benchmark `cli::cli_warn()` against base R's `base::warning()` to\nsee if the former has any speed issues. The results of this exercise will\nprovide us with insights on whether its worth taking on `cli` for its features\nas a trade-off for slower printing speed.\n\n## Experiment\n\nWe will consider different scenarios of number of warnings thrown to\ntease out the relationship between speed of the function and number of warnings\nthrown in a function with and without `cli::cli_warn()`. We will also check how\nthe benchmark scales with the number of warnings in the function.\n\nBased on this description, we will need the following packages: `cli` for its\nwarning function, and [bench](https://cran.r-project.org/web/packages/bench/index.html)\nfor measuring the run times,  [dplyr](https://dplyr.tidyverse.org/)\nfor manipulating the results, and [ggplot2](https://ggplot2.tidyverse.org/)\nfor plotting.\n\nLet's define a function that takes an argument `n` for the number of warnings\nto throw and `pkg` for the type of package to use.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwarn_Ntimes <- function(n, pkg) {\n  warning_msg <- \"x must be an integer\"\n  switch(pkg,\n    base = for (i in seq_len(n)) {\n      warning(warning_msg)\n    },\n    cli = for (i in seq_len(n)) {\n      cli_warn(warning_msg)\n    }\n  )\n}\n```\n:::\n\n\nLet's test our function to see if it works as expected.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwarn_Ntimes(3, \"base\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in warn_Ntimes(3, \"base\"): x must be an integer\n\nWarning in warn_Ntimes(3, \"base\"): x must be an integer\n\nWarning in warn_Ntimes(3, \"base\"): x must be an integer\n```\n\n\n:::\n\n```{.r .cell-code}\nwarn_Ntimes(3, \"cli\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: x must be an integer\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: x must be an integer\nx must be an integer\n```\n\n\n:::\n:::\n\n\nNow, we'll consider scenarios where a function throws 1, 5, 10, 15, 20, and\n100 warnings using base R and `cli`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Number of warnings to throw\nwarnings <- c(1, 5, 10, 15, 20, 100)\n```\n:::\n\n\nLet's run benchmarks over the different scenarios and store results\nin a data.frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbnmark_res <- press(\n  warnings = c(1, 5, 10, 15, 20, 100),\n    mark(\n      cli = warn_Ntimes(warnings, \"cli\"),\n      base = warn_Ntimes(warnings, \"base\")\n    )\n  )\n```\n:::\n\n\n## Results\n\nIt's time to explore the results of the data generated. Let's first make a\nboxplot of the run times for the different scenarios.\n\nDrum roll please...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nautoplot(\n  bnmark_res,\n  type = \"boxplot\"\n  ) +\n  labs(\n    x = \"Package\",\n    caption = \"Functions throwing various numbers of warnings as indicated in the facet label\"\n  )\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nLoading required namespace: tidyr\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nNow, let's see how the benchmarks scale with the number of warnings thrown.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbnmark_res$pkg <- attr(bnmark_res$expression, \"description\")\n\nggplot(bnmark_res) +\n  geom_line(\n    aes(\n      x = warnings,\n      y = median,\n      color = pkg\n    ),\n    linewidth = 2\n  ) +\n  labs(\n    x = \"Number of warnigns\",\n    y = \"Median execution time\",\n    color = \"Package\"\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\nAs we can see, `cli` is consistently slower than base R for the same number of\nwarnings thrown. The median times also follow a similar non-linear trajectory.\nBenchmarking experiments with other `cli` functions have revealed similar non-linear\nrelationships between its speed and the number of times it invokes those\nfunctions [^2]. However, those exercises were not compared with equivalent functions\nin base R. The relative comparison here is useful for decision-making.\n\nThe developers of `cli` have also conducted benchmarks of the `ansi_*()` family\nof functions in `cli` in comparison to base R and the `fansi` package.\nThey find that `cli` is consistently slower than base R, which corroborates the\nresults of our experiment here. These benchmarks are available in the `cli`\ndocumentation [^3].\n\nSo, should we be worried about the speed of `cli`? Well, it depends on the context.\nThe \"R Packages\" book by Hadley Wickham and Jenny Bryan suggests approaching\nsuch a decision from a holistic, balanced, and quantitative\napproach[@wickham2023r]. We'll leave the reader to make their own decision\nbased on their use case.\n\nMost developers might argue that this is an optimisation overkill[^4]. However,\nit is important to consider speed differences in context.\nIn the case of simple printing, the speed difference is\nnegligible yet disruptive and somewhat painful. However, in the grand scheme\nof things, this might be nothing compared with much slower processes that\nneed more attention. In those cases, the developer might want to consider other\noptimisation strategies such as profiling [^5]. The essence of this experiment\nis to demonstrate the utility of benchmarking in making quick design decisions.\n\n## Conclusion\n\nIn designing R package infrastructure with dependencies, it might\nsometimes be necessary to check if they don't slow down existing processes.\nHere, we have demonstrated how benchmarking is one way to achieve\nthis for a process involving condition signalling. We show how a simple\ndecision to use `cli::cli_warn()` to handle warnings could come at the cost of\na tiny loss in speed, which is worth considering in its context.\n\nThe demonstration here can be extended to other dependency adoption decisions for\ninput checking, loops, object manipulations, and so forth. We recommend benchmarking\nas a way to help developers make quick design decisions. However, we also recommend\nthat developers consider the context of the optimisation in interpreting the results.\n\n*I would like to thank [Pratik Gupte](https://github.com/pratikunterwegs),\n[Joshua Lambert](https://github.com/joshwlambert), and\n[Hugo Gruson](https://github.com/Bisaloo) for their invaluable reviews and\nsuggestions that helped improve this post.*\n\n## Other R packages for benchmarking\n\n* [microbenchmark](https://github.com/joshuaulrich/microbenchmark): an R\n  package for comparing the execution time of R expressions.\n* [rbenchmark](https://code.google.com/archive/p/rbenchmark/): an R package\n  for benchmarking R code.\n* [tictok](https://github.com/collectivemedia/tictoc): an R package to time\nR functions\n* [touchstone](https://github.com/lorenzwalthert/touchstone/tree/main): an R\n  package for\n  benchmarking of pull requests with statistical confidence.\n\n[^1]: Benchmark (Wikipedia): <https://en.wikipedia.org/wiki/Benchmark_(computing)>\n[^2]: Formating errors can be slow/variable: <https://github.com/r-lib/cli/issues/617>\n[^3]: cli benchmarks: <https://cli.r-lib.org/articles/ansi-benchmark.html>\n[^4]: Donald Knuth's quoted as having said, \"The real problem is that programmers have spent far too much time worrying about efficiency in the wrong places and at the wrong times; premature optimization is the root of all evil (or at least most of it) in programming.\" (See <https://en.wikiquote.org/wiki/Donald_Knuth>)\n[^5]: Profiling (Wikipedia): <https://csgillespie.github.io/efficientR/performance.html>\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}