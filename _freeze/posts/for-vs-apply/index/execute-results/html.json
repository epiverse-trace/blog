{
  "hash": "a4cc084fadcc225e9f6c4441a04cc94b",
  "result": {
    "markdown": "---\ntitle: \"Lesser-known reasons to prefer `apply()` over for loops\"\nauthor:\n  - name: \"Hugo Gruson\"\n    orcid: \"0000-0002-4094-1476\"\ndate: \"2023-11-02\"\ncategories: [R, functional programming, iteration, readability, good practices]\nformat:\n  html: \n    toc: true\neditor: \n  markdown: \n    wrap: 80\n---\n\n\nThe debate regarding the use of `for` loops versus the `apply()` function family\n(`apply()`, `lapply()`, `vapply()`, etc., along with their purrr counterparts:\n`map()`, `map2()`, `map_lgl()`, `map_chr()`, etc.), has been a longstanding one\nin the R community.\n\nWhile you may occasionally hear that `for` loops are slower, this notion has\nalready been debunked [in other\nposts](https://privefl.github.io/blog/why-loops-are-slow-in-r/). When utilized\ncorrectly, a `for` loop can achieve performance on par with `apply()` functions.\n\nHowever, there are still lesser-known reasons to prefer `apply()` functions over\n`for` loops, which we will explore in this post.\n\n## Preamble: `for` loops can be used in more cases than `apply()`\n\nIt is important to understand that `for` loops and `apply()` functions are not\nalways interchangeable. Indeed, `for` loops can be used in cases where `apply`\nfunctions can't: when the next step depends on the previous one. This concept is\nknown as [*recursion*](https://en.wikipedia.org/wiki/Recursion).\n\nConversely, when each step is independent of the previous one, but you want to\nperform the same operation on each element of a vector, it is referred to as\n[*iteration*](https://en.wikipedia.org/wiki/Iteration).\n\n`for` loops are capable of both *recursion* and *iteration*, whereas `apply()`\ncan only do *iteration*.\n\n| Operator  | Iteration | Recursion |\n|-----------|-----------|-----------|\n| `for`     | ✔️        | ✔️        |\n| `apply()` | ✔️        | ❌        |\n\nWith this distinction in mind, we can now focus on why you should favour\n`apply()` for iteration over `for` loops.\n\n## Reason 1: clarity of intent\n\nAs mentioned earlier, `for` loops can be used for both iteration and recursion.\nBy consistently employing `apply()` for iteration[^caveat] and reserving `for` loops for\nrecursion, we enable readers to immediately discern the underlying concept in\nthe code. This leads to code that is easier to read and understand.\n\n[^caveat]: There are a handful of rare corner cases where `apply()` is not the best method for iteration. These are cases that make use of `match.call()` or `sys.call()`. More details are available in `lapply()` documentation and in [this GitHub comment by Tim Taylor during the review of this post](https://github.com/epiverse-trace/epiverse-trace.github.io/pull/125#issuecomment-1775929451).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl <- list(c(1, 2, 6), c(3, 5), 6, c(0, 9, 3, 4, 8))\n\n# `for` solution -------------------\nres <- numeric(length(l))\nfor (i in seq_along(l)) {\n  res[[i]] <- mean(l[[i]])\n}\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.0 4.0 6.0 4.8\n```\n\n\n:::\n\n```{.r .cell-code}\n# `vapply()` solution ---------------\nres <- vapply(l, mean, numeric(1))\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.0 4.0 6.0 4.8\n```\n\n\n:::\n:::\n\n\nThe simplicity of `apply()` is even more apparent in the case of multiple iterations. For example, if we want to find the median of each matrix row for a list of matrices:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl <- replicate(5, { matrix(runif(9), nrow = 3) }, simplify = FALSE)\n\n# `for` solution -------------------\nres <- list()\nfor (i in seq_along(l)) {\n  meds <- numeric(nrow(l[[i]]))\n  for (j in seq_len(nrow(l[[i]]))) {\n    meds[[j]] <- median(l[[i]][j, ])\n  }\n  res[[i]] <- meds\n}\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 0.4649759 0.2207012 0.6641384\n\n[[2]]\n[1] 0.7294329 0.5922619 0.2698467\n\n[[3]]\n[1] 0.6492639 0.5704303 0.3644155\n\n[[4]]\n[1] 0.6646998 0.5034247 0.3045794\n\n[[5]]\n[1] 0.1697894 0.1721191 0.2859237\n```\n\n\n:::\n\n```{.r .cell-code}\n# `vapply()` solution ---------------\nlapply(l, function(e) {\n  apply(e, 1, median)\n})\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] 0.4649759 0.2207012 0.6641384\n\n[[2]]\n[1] 0.7294329 0.5922619 0.2698467\n\n[[3]]\n[1] 0.6492639 0.5704303 0.3644155\n\n[[4]]\n[1] 0.6646998 0.5034247 0.3045794\n\n[[5]]\n[1] 0.1697894 0.1721191 0.2859237\n```\n\n\n:::\n:::\n\n\nMoreover, this clarity of intent is not limited to human readers alone;\nautomated static analysis tools can also more effectively identify suboptimal\npatterns. This can be demonstrated using R most popular static analysis tool:\nthe lintr package, suggesting vectorized alternatives:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlintr::lint(text = \"vapply(l, length, numeric(1))\")\n\nlintr::lint(text = \"apply(m, 1, sum)\")\n```\n:::\n\n\n## Reason 2: code compactness and conciseness\n\nAs illustrated in the preceding example, `apply()` often leads to more compact\ncode, as much of the boilerplate code is handled behind the scenes: you don't\nhave to initialize your variables, manage indexing, etc.\n\nThis, in turn, impacts code readability since:\n\n- The boilerplate code does not offer meaningful insights into the algorithm or\n  implementation and can be seen as visual noise.\n- While compactness should never take precedence over readability, a more\n  compact solution allows for more code to be displayed on the screen without\n  scrolling. This ultimately makes it easier to understand what the code is\n  doing. With all things otherwise equal, the more compact solution should thus\n  be preferred.\n\n## Reason 3: variable leak\n\nAs discussed in the previous sections, you have to manually manage the iteration\nindex in a `for` loop, whereas they are abstracted in `apply()`. This can\nsometimes lead to perplexing errors:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nk <- 10\n\nfor (k in c(\"Paul\", \"Pierre\", \"Jacques\")) {\n  message(\"Hello \", k)\n}\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHello Paul\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHello Pierre\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nHello Jacques\n```\n\n\n:::\n\n```{.r .cell-code}\nrep(letters, times = k)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: NAs introduced by coercion\n```\n\n\n:::\n\n::: {.cell-output .cell-output-error}\n\n```\nError in rep(letters, times = k): invalid 'times' argument\n```\n\n\n:::\n:::\n\n\nThis is because the loop index variable leaks into the global environment and\ncan overwrite existing variables:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (k in 1:3) {\n  # do something\n}\n\nmessage(\"The value of k is now \", k)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nThe value of k is now 3\n```\n\n\n:::\n:::\n\n\n## Reason 4: pipelines\n\nThe final reason is that `apply()` (or more commonly in this situation\n`purrr::map()`) can be used in pipelines due to their functional nature:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl <- list(c(1, 2, 6), c(3, 5), 6, c(0, 9, 3, 4, 8))\n\n# Without pipe\nvapply(l, mean, numeric(1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.0 4.0 6.0 4.8\n```\n\n\n:::\n\n```{.r .cell-code}\n# With pipe\nl |> vapply(mean, numeric(1))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.0 4.0 6.0 4.8\n```\n\n\n:::\n\n```{.r .cell-code}\nl |> purrr::map_dbl(mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.0 4.0 6.0 4.8\n```\n\n\n:::\n:::\n\n\n## Conclusion\n\nThis post hopefully convinced you why it's better to use `apply()` functions\nrather than `for` loops where possible (i.e., for iteration). Contrary to common\nmisconception, the real reason is not performance, but code robustness and\nreadability.\n\n*Thanks to Jaime Pavlich-Mariscal, James Azam, Tim Taylor, and Pratik Gupte for\ntheir thoughtful comments and suggestions on earlier drafts of this post.*\n\n::: {.callout-tip title=\"Beyond R\"}\n\nThis post focused on R, but the same principles generally apply to other\nfunctional languages. In Python for example, you would use [list\ncomprehensions](https://www.w3schools.com/python/python_lists_comprehension.asp)\nor the [`map()` function](https://www.w3schools.com/python/ref_func_map.asp).\n\n:::\n\n::: {.callout-tip title=\"Further reading\"}\n\nIf you liked the code patterns recommended in this post and want to use functional programming in more situations, including recursion, I recommend you check out the [\"Functionals\" chapter of the *Advanced R* book by Hadley Wickham](https://adv-r.hadley.nz/functionals.html#functionals)\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}