{
  "hash": "7df29ba763a506a973c94d741377194b",
  "result": {
    "markdown": "---\ntitle: \"Benchmarking as a tool for R package design decision-making\"\nauthor:\n  - name: \"James Mba Azam\"\n    orcid: \"https://orcid.org/0000-0001-5782-7330\"\ndate: \"2023/04/25\"\ncategories: [benchmarking, data-driven design, R packages]\nformat:\n  html:\n    toc: true\n---\n\n::: {.cell}\n\n:::\n\n\n## Motivation\n\nUser-friendliness or user experience is a key driver of design decisions in\nR package development. When writing user-facing functions in R packages\ndevelopers are often faced with alternative decisions for achieving the same \ntask. An example is how a function should behave when things go wrong, but not\nterribly wrong to cause issues downstream. In such cases, the developer\nhas to decide whether to throw a warning and fix the issue internally or \nto throw an error and make the user fix the issue. Either options would be \nfine but the developer will have to manage their side effects. For example, \nthrowing an error every time something goes wrong can be annoying to the user. \n\nLet us take a concrete example. In simulation studies, (model/simulation) \nfunctions are often run multiple times, and most times in orders of magnitude.\nRun times are therefore important and functions designed for that purpose \nshould ideally be optimised for speed.\n\nBase R provides a host of functions to achieving various tasks. However, this is\noften not enough and developers need more functionality outside of base R. \nMoreover, in order not to reinvent the wheel, developers often take on \ndependencies, aside those provided in base R, from other packages to \nperform tasks in their own packages. There are packages\nfor cleaning up messy model output, for example, [broom](https://cran.r-project.org/web/packages/broom/vignettes/broom.html), for\nsummarising model output, example, [modelsummary](https://github.com/vincentarelbundock/modelsummary), \nfor printing nice tables, example [kableExtra](https://cran.r-project.org/web/packages/kableExtra/vignettes/awesome_table_in_html.html), and for plotting, for example,\n[ggplot2](https://ggplot2.tidyverse.org/).\n\nHere, we will study the example of catching and throwing warnings in R. \nWe will demonstrate how the decision about what package to use to\nthrow a warning or an error in non-fatal events could affect a \nfunction's run time on a computer.\n\n### Example: warnings vs errors\n\nWe consider an example where a developer has to decide whether to throw\nwarnings or errors in some non-fatal events.\n\nAn example can be found in Epiverse's `bpmodels` package where a function \nwas previously throwing an error for a disallowed combination of arguments \nbut was later [changed to throw a warning](https://github.com/epiverse-trace/bpmodels/pull/53). As part of \nthe change the wrongly specified argument would be fixed internally with \na warning to inform the user of what has happened.\n\nThis decision was intended to improve user experience. However, it also \nmeant that in a situation where this happens at scale, the warning \nwould be thrown as many times as the number of simulations unless \nit is fixed.\n\nThrowing warnings can be useful so as to allow the function to run \nsmoothly, especially if an action (for example, certain combinations \nof arguments are not allowed but not fatal). In a situation where a \nfunction throws a warning and is often run multiple times, it would \nbe important that this event does not slow down the the process at\nscale.\n\nHere, we will demonstrate that such a decision can be driven by data \ngenerated from benchmarking.\n\n## Experiment: throwing warnings with base::warning() vs cli::cli_warn()\n\nLet us benchmark a function that uses `cli::cli_warn()` vs `base::warning()`. \nHere, we choose `cli::cli_warn()` because it has well adopted in the developer \ncommunity as an alternative to `base::warning()`. Moreover, `cli` helps to \nprovide useful feedback to the user and can be easy and fun to use as a \ndeveloper when they get a hang of it.\n\n### Setup 1: one arg validation and one warning\n\nWe will define a function that takes an input, which is expected to be an \ninteger, else a warning is thrown. For the purpose of this exercise, we \nassume that a non-integer input is not preferred but is not fatal.\n\nBased on this description, we will need 2 main packages, [cli](https://cli.r-lib.org/articles/semantic-cli.html) for the function \nin question here and microbenchmark\\](https://cran.r-project.org/web/packages/microbenchmark/index.html) to measure the run times. We will also use an optional one, [checkmate](https://cran.r-project.org/web/packages/checkmate/index.html) to \nvalidate the input, however, the reader may write their own checks and avoid \ntaking on `checkmate` as a dependency.\n\nLet us load the packages\n\n\n::: {.cell hash='benchmarking_design_decisions_cache/html/unnamed-chunk-2_3bf1ed9da5e414b859a5c274af8b23d9'}\n\n```{.r .cell-code}\nlibrary(microbenchmark)\nlibrary(cli)\nlibrary(checkmate)\n```\n:::\n\n\n#### One `base::warning()` instance\n\nLet us define a function to throw a warning using base R, if an input is \nnot an integer.\n\n\n::: {.cell hash='benchmarking_design_decisions_cache/html/unnamed-chunk-3_664f0d74f3bcb7bce49230bb88f66439'}\n\n```{.r .cell-code}\nbase_warn_bmrk <- function(x){\n  if (!checkmate::testInteger(x)) {\n    warning(\"x must be an integer\")\n  }\n}\n```\n:::\n\n\nLet's test `base_warn_bmrk()`.\n\n\n::: {.cell hash='benchmarking_design_decisions_cache/html/unnamed-chunk-4_c3906329d5598b92c9abda125f61e7b2'}\n\n```{.r .cell-code}\nbase_warn_bmrk(x = 1.2)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in base_warn_bmrk(x = 1.2): x must be an integer\n```\n:::\n:::\n\n\nAs we can see, it works as expected.\n\nNow, let's define a function to throw a warning using {cli_warn}, if an \ninput is not an integer.\n\n#### One `cli::cli_warn()` instance\n\n\n::: {.cell hash='benchmarking_design_decisions_cache/html/unnamed-chunk-5_dc00c445a42f040565bd201beafe849c'}\n\n```{.r .cell-code}\ncli_warn_bmrk <- function(x){\n  if (!checkmate::testInteger(x)) {\n    cli_warn(c(\n      \"x must be an integer\",\n      \"i\" = \"x is currently an {.cls {class(x)}}\",\n      \"x\" = \"x is not an integer\"\n    )\n    )\n  }\n}\n```\n:::\n\n\nLet's test `cli_warn_bmrk()`:\n\n\n::: {.cell hash='benchmarking_design_decisions_cache/html/unnamed-chunk-6_5c9d77f6faa3b7673ed7ccf8dab4a476'}\n\n```{.r .cell-code}\ncli_warn_bmrk(x = 1.2)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: x must be an integer\nℹ x is currently an <numeric>\n✖ x is not an integer\n```\n:::\n:::\n\n\n`cli_warn_bmrk()` also works as expected.\n\nWe will also check if the benchmark scales with the number of warnings in \nthe function. To do this, we will modify the original functions to take \ntwo inputs, both of which are expected to be integers and follow the same \nlogic as before.\n\n### Setup 2: two argument validation and two warnings\n\n#### Two `base::warning()` instances\n\nLet us define a function to throw a warning using base R, if an input is \nnot an integer.\n\n\n::: {.cell hash='benchmarking_design_decisions_cache/html/unnamed-chunk-7_8a99b3e5d87b0c63858a2aa84f3a165e'}\n\n```{.r .cell-code}\nbase_warn_bmrk2 <- function(x, y){\n  # Validate arg x\n  if (!checkmate::testInteger(x)) {\n    warning(\"x must be an integer\")\n  }\n  \n  # Validate arg y\n  if (!checkmate::testInteger(y)) {\n    warning(\"y must be an integer\")\n  }\n}\n```\n:::\n\n\nLet's test `base_warn_bmrk2()`.\n\n\n::: {.cell hash='benchmarking_design_decisions_cache/html/unnamed-chunk-8_c9fb4445dee764b05282ad8786fc38af'}\n\n```{.r .cell-code}\nbase_warn_bmrk2(x = 1.2, y = 1.23)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in base_warn_bmrk2(x = 1.2, y = 1.23): x must be an integer\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in base_warn_bmrk2(x = 1.2, y = 1.23): y must be an integer\n```\n:::\n:::\n\n\n`base_warn_bmrk2` works as expected.\n\n#### Two `cli::cli_warn()` instances\n\n\n::: {.cell hash='benchmarking_design_decisions_cache/html/unnamed-chunk-9_1acabe06953239063d5383b53e71919b'}\n\n```{.r .cell-code}\ncli_warn_bmrk2 <- function(x, y){\n  # Validate arg x\n  if (!checkmate::testInteger(x)) {\n    cli_warn(c(\n      \"x must be an integer\",\n      \"i\" = \"x is currently an {.cls {class(x)}}\",\n      \"x\" = \"x is not an integer\"\n    )\n    )\n  }\n  \n  # Validate arg y\n    if (!checkmate::testInteger(y)) {\n    cli_warn(c(\n      \"y must be an integer\",\n      \"i\" = \"y is currently an {.cls {class(x)}}\",\n      \"x\" = \"y is not an integer\"\n    )\n    )\n  }\n  \n}\n```\n:::\n\n\nLet's test `cli_warn_bmrk2()`:\n\n\n::: {.cell hash='benchmarking_design_decisions_cache/html/unnamed-chunk-10_fe120ddfdd184751de289050e7e5b888'}\n\n```{.r .cell-code}\ncli_warn_bmrk2(x = 1.2, y = 1.25)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: x must be an integer\nℹ x is currently an <numeric>\n✖ x is not an integer\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: y must be an integer\nℹ y is currently an <numeric>\n✖ y is not an integer\n```\n:::\n:::\n\n\n`cli_warn_bmrk2()` also works as expected.\n\nNow, to the fun part, let us run the functions $1000$ times and plot \nthe results.\n\n## Results\n\n### The case of 1 arg validation and 1 warning\n\nHere, as we know the functions will throw warnings, we will suppress \nthem to avoid cluttering this article with their outputs.\n\n\n::: {.cell hash='benchmarking_design_decisions_cache/html/unnamed-chunk-11_e94308aa0f7224761d051179937dca28'}\n\n```{.r .cell-code}\nreps <- 1000\n\ninput_vec <- 1.2 \n\nbnmrk_df <- microbenchmark(\n  cli_warn = cli_warn_bmrk(x = input_vec),\n  base_warn = base_warn_bmrk(x = input_vec),\n  times = reps\n)\n\nboxplot(bnmrk_df)\ntitle(paste(\"Function with 1 argument of length 1 and throws 1 warning (replicated\", reps, 'times)'))\n```\n\n::: {.cell-output-display}\n![](benchmarking_design_decisions_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nLet us try this with a mixed vector of length $10$ and see how that scales up.\n\n\n::: {.cell hash='benchmarking_design_decisions_cache/html/unnamed-chunk-12_fb0982ec597bfdec3672855980c151e6'}\n\n```{.r .cell-code}\nset.seed(123)\n\nreps <- 1000\n\ninput_vec2 <- c(runif(5, 0, 10), sample.int(6, 5))\n\nbnmrk_df2 <- microbenchmark(\n  cli_warn = cli_warn_bmrk(x = input_vec2),\n  base_warn = base_warn_bmrk(x = input_vec2),\n  times = reps\n)\n\nboxplot(bnmrk_df2)\ntitle(paste(\"Function with 1 argument of length 10 and throws 1 warning (replicated\", reps, 'times)'))\n```\n\n::: {.cell-output-display}\n![](benchmarking_design_decisions_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n### The case of 2 arg validation and 2 warnings\n\n\n::: {.cell hash='benchmarking_design_decisions_cache/html/unnamed-chunk-13_41920bb7bceab9a18038c568b3a7d6d7'}\n\n```{.r .cell-code}\nreps <- 1000\n\narg_x <- 1.2 \n\narg_y <- 1.25\n\nbnmrk_df3 <- microbenchmark(\n  cli_warn = cli_warn_bmrk2(x = arg_x, y = arg_y),\n  base_warn = base_warn_bmrk2(x = arg_x, y = arg_y),\n  times = reps\n)\n\nboxplot(bnmrk_df3)\n\ntitle(paste(\"Function with 2 arguments of length 1 each and throws 2 warning (replicated\", reps, 'times)'))\n```\n\n::: {.cell-output-display}\n![](benchmarking_design_decisions_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\nWe can see from this simple example that `cli::cli_warn()` was $100$ times \nslower on average than `base::warn()`. Additionally, the benchmark was not\naffected by the length of the input but rather scaled linearly with the \nnumber of calls to the warning functions.\n\n## Conclusion\n\nIn designing R package infrastructure, it is important that the developer(s) \nconsiders the impact of user-facing decisions. Here, we have demonstrated \nhow this decision can be driven with data from benchmarking exercises. \nWe show how a simple decision to use `cli::cli_warn()` to throw warnings \ncould affect function run times.\n\nThe demonstration here can be extended to other design decisions. \nWe recommend benchmarking as a way to help the developer make design \ndecisions.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}