{
  "hash": "2fde11041aff189be02b5d60b3f477ed",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Improving Ecosystem Interoperability Iteratively via Progressive Enhancement\"\nauthor:\n  - name: \"Hugo Gruson\"\n    orcid: \"0000-0002-4094-1476\"\ndate: \"2024-07-04\"\ncategories: [R, interoperability, S3, progressive enhancement, ecosystem, lifecycle, object orientation, DOI]\nformat:\n  html: \n    toc: true\n---\n\n\nWe are continuing our post series on S3 and interoperability.\nWe have previously discussed [what makes a good S3 class and how to choose a good parent for it, as well as when to write or not write a custom method](../parent-class).\nWe have highlighted in particular how classes inheriting from data.frames can simplify user experience because of familiarity, and reduce developer workload due to the pre-existing S3 methods.\n\nWe have detailed how to improve compatibility with the tidyverse by explaining:\n\n- [how functions taking data.frames or data.frames subclass should also allow compatibility with tibble, which can be done in a few steps](https://hugogruson.fr/posts/compa-tibble/)\n- [how to ensure class attributes are preserved whenever possible while using dplyr functions](../extend-dataframes).\n\nHere, we are going to explore how to start adding support in the ecosystem for the new S3 classes while minimizing user-facing breaking changes.\nWe have previously delved into this topic with our post [\"Convert Your R Function to an S3 Generic: Benefits, Pitfalls & Design Considerations\"](../s3-generic) and this is a wider and higher-level view of the same topic.\n\nThe strategy presented here is the variation of a common concept in web development and the web ecosystem: [progressive enhancement](https://developer.mozilla.org/en-US/docs/Glossary/Progressive_Enhancement). This philosophy aims to support browsers with limited range of features, while allowing a slightly richer experience for browsers with extra features.\nIt makes sense to think about this philosophy with the prism of introducing new classes to a new software ecosystem as it has the similar constraints of multiple stakeholders with different interests and timelines.\nThe application of progressive enhancement in this context means that users or packages that did not (yet) adopt the new classes are not penalized compared to users or packages that did.\n\n## Adding class support to function inputs via progressive enhancement\n\nThe goal here is to allow functions to accept the new classes as inputs, while keeping the old behaviour unchanged for unclassed objects (or with a different class than the new one).\n\nThis can conveniently be done in an almost transparent way by converting the old function to the S3 generic, and using the default method to handle the old behaviour. The practical steps, and minor caveats, have been previously described in the post [\"Convert Your R Function to an S3 Generic: Benefits, Pitfalls & Design Considerations\"](../s3-generic).\n\n![A before / after type image showing the conversion of a function to a generic with a default method keeping the exisiting behaviour.](convert_to_generic.svg)\n\nFor a different, additional, example, we can consider a function working on patient-level data, which previously only accepted a `data.frame` as input:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Compute length of stay in hospital on a patient-level dataset\n#'\n#' @param data A data.frame containing patient-level data\n#' @param admission_column The name of the column containing the admission date\n#' @param discharge_column The name of the column containing the discharge date\n#'\n#' @returns A numeric vector of hospitalization durations in days\ncompute_hospitalization_duration <- function(data, admission_column, discharge_column) {\n\n  difftime(\n    data[[discharge_column]],\n    data[[admission_column]],\n    units = \"days\"\n  )\n\n}\n```\n:::\n\n\nWe want to add support for `linelist` objects, as defined in the [linelist package](https://epiverse-trace.github.io/linelist). `linelist` objects inherit from `data.frame` and contain an additional `tags` attribute. In particular, `linelist` objects can have a `date_admission` and `date_discharge` tag. This means we can use the tags to automatically detect the columns to use.\n\nBut we want the function to keep working for standard `data.frame`s, `tibble`s, etc. We can follow the steps described in the previous post to convert the function to a generic, and add a default method to handle the old behaviour:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncompute_hospitalization_duration <- function(data, ...) {\n\n  UseMethod(\"compute_hospitalization_duration\")\n\n}\n\ncompute_hospitalization_duration.default <- function(data, admission_column, discharge_column) {\n\n  difftime(\n    data[[discharge_column]],\n    data[[admission_column]],\n    units = \"days\"\n  )\n\n}\n\ncompute_hospitalization_duration.linelist <- function(data, ...) {\n\n  x <- linelist::tags_df(data)\n\n  compute_hospitalization_duration(\n    data = x,\n    admission_column = \"date_admission\",\n    discharge_column = \"date_discharge\"\n  )\n\n}\n```\n:::\n\n\nIf the function was already a generic, then a new method for the new class should be added, leaving everything else unchanged.\n\n## Adding class support to function outputs via progressive enhancement\n\nAdding class support to function outputs is often more challenging.\nA common option is to add a new argument to the function, which would be a boolean indicating whether the output should be of the new class or not.\nBut this doesn't fit in the view of progressive enhancement, as it would require users to change their code to benefit from the new classes, or to suffer from breaking changes.\n\nWhile the new argument approach is sometimes indeed the only possible method, there are some situations where we can have an approach truly following the progressive enhancement philosophy.\n\nIn particular, this is the case when the old output was already inheriting from the parent of the new class (hence the importance of carefully choosing the parent class). In this situation, the new attributes from the new class should not interfere with existing code for downstream analysis.\n\nIn this case, let's consider a function that was previously returning an unclassed `data.frame` with patient-level data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreate_patient_dataset <- function(n_patients = 10) {\n\n  data <- data.frame(\n    patient_id = seq_len(n_patients),\n    age = sample(18:99, n_patients, replace = TRUE)\n  )\n\n  return(data)\n\n}\n```\n:::\n\n\nWe want to start returning a `linelist` object. Because `linelist` objects are `data.frame`s (or `tibble`s) with an extra `attr`, it can be done in a transparent way:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreate_patient_dataset <- function(n_patients = 10) {\n\n  data <- data.frame(\n    patient_id = seq_len(n_patients),\n    age = sample(18:99, n_patients, replace = TRUE)\n  )\n\n  data <- linelist::make_linelist(\n    data,\n    id = \"patient_id\",\n    age = \"age\"\n  )\n\n  return(data)\n\n}\n\ninherits(data, \"data.frame\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\nFor a more realistic example, you can also see the work in progress to integrate the [new `contactmatrix` standard format](https://github.com/socialcontactdata/contactmatrix) for social contact data to the [contactdata package](https://github.com/Bisaloo/contactdata).\n\nThis is however only true if code in downstream analysis follows good practices [^1]. If existing code was testing equality of the class to a certain value, it will break when the new class value is appended. This is described in a [post on the R developer blog, when base R was adding a new `array` class value to `matrix` objects](https://developer.r-project.org/Blog/public/2019/11/09/when-you-think-class.-think-again/index.html). Class inheritance should never be tested via `class(x) == \"some_class\"`. Instead, `inherits(x, \"some_class\")` or `is(x, \"some_class\")` should be used to future-proof the code and allow appending an additional in the future.\n\n[^1]: This is now [enforced in R packages by R CMD check](https://github.com/r-devel/r-svn/commit/77ebdff5adc200dfe9bc850bc4447088830d2ee0), and via the [`class_equals_linter()`](https://lintr.r-lib.org/reference/class_equals_linter.html)  in the [lintr package](https://lintr.r-lib.org/).\n\n## Conclusion\n\nObject oriented programming and S3 classes offer a convenient way to iteratively add interoperability in the ecosystem in a way that is minimally disruptive to users and developers.\nNewly classed input support can be added via custom methods (after converting the existing function to a generic if necessary).\nNewly classed output support can be added via progressive enhancement, by ensuring that the new class is a subclass of the old one, that downstream code uses good practices.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}