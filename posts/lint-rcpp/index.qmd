---
title: "Improving the C++ Code Quality of an Rcpp Package"
author: "Pratik R Gupte"
date: "2022-12-02"
categories: [code quality, R package, Rcpp]
format:
  html:
    toc: true
---

## Use case

The R package development ecosystem includes packages such as [{lintr}](https://lintr.r-lib.org/) and [{styler}](https://styler.r-lib.org) that can help to check code style, and to format R code.

However, these packages cannot lint or style the C++ code of [{Rcpp}](https://www.rcpp.org/) packages. This could leave the C++ code of an Rcpp package less clean than the R code, increasing the technical debt already associated with using two-languages.

In the Epiverse, we encounter this issue with [{finalsize}](https://epiverse-trace.github.io/finalsize/), and we anticipate the same issue with further epidemic modelling packages that we seek to develop or adapt, such as [{fluEvidenceSynthesis}](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1005838).

## Choice of C++ linters

C++ linters such as [_clang-tidy_](https://clang.llvm.org/extra/clang-tidy/) stumble when dealing with C++ code in `src/`, as the _clang_ toolchain attempts to compile it. This does not work for Rcpp packages, as the `Rcpp.h` header cannot be found --- this linking is handled by {Rcpp}.

Fortunately, other C++ linters and code checking tools are available and can be used safely with Rcpp packages.

We have chosen to use _cpplint_ and _cppcheck_ for {finalsize}.

### Cpplint

[_cpplint_](https://github.com/cpplint/cpplint) is a tool that checks whether C/C++ files follow [Google's C++ style guide](http://google.github.io/styleguide/cppguide.html). _cpplint_ is (1) Easy to install across platforms, (2) Easily instructed to ignore the `RcppExports.cpp` file, so as to preserve its formatting, and (3) Does not error when it cannot find `Rcpp.h`.

_cpplint_ can be run locally from the terminal, and instructed to not lint `RcppExports.cpp`, but all other `.cpp` files in `src/`.

```sh
cpplint --exclude="src/RcppExports.cpp" src/*.cpp
```

### Cppcheck

[_cppcheck_](https://cppcheck.sourceforge.io/) is a static code analysis tool, that aims to "have very few false positives". This is especially useful for the non-standard organisation of Rcpp projects compared to C++ projects.

_cppcheck_ can also be run locally and instructed to ignore the autogenerated `RcppExports.cpp` file, while throwing up issues with style.

```sh
cppcheck -i src/RcppExports.cpp --enable=style --error-exitcode=1 src
```

Here, the `--enable=style` option lets _cppcheck_ flag issues with style, acting as a second linter.
Enabling all checks (`--enable=all`) would flag issues with the `Rcpp.h` header not being found (of the class `missingIncludeSystem`), or with the solver functions not being used (`unusedFunction`). 

These extra options should be avoided in Rcpp packages, as the linking is handled for us, and the functions are indeed used later --- just not by other C++ functions.

## Adding C++ linting to CI workflows

Both _cpplint_ and _cppcheck_ can be easily added to continuous integration workflows. In the Epiverse, we use Github Actions. The C++ lint workflow we have implemented looks like this:

```yaml
on:
  push:
    paths: "src/**"
  pull_request:
    branches:
      - "*"

name: Cpp-lint-check

jobs:
  cpplint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-python@v2
      - run: pip install cpplint
      - run: cpplint --quiet --exclude="src/RcppExports.cpp" src/*.cpp

  cppcheck:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - run: sudo apt-get install cppcheck
      - run: cppcheck -isrc/RcppExports.cpp --quiet --enable=warning --error-exitcode=1 .
```

The workflow is triggered when there are changes to files in `src/`, and on all pull requests.

## Formatting C++ code

C++ code can be automatically formatted to avoid linter errors.
An especially useful tool is [_clang-format_](https://clang.llvm.org/docs/ClangFormat.html). Our code is styled to follow the [Google C++ style guide](https://google.github.io/styleguide/cppguide.html) using:

```sh
clang-format -i -style=google src/*.cpp
```

However, this also formats the autogenerated `RcppExports.cpp` file.
It can be extra work to repeatedly undo this change and keep the original formatting, or to repeatedly re-style the file as it's rewritten after each call to `Rcpp::compileAttributes()`.
One solution is to include stylers in a pre-commit action called a ['git hook'](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks), so that the file is always styled before committing, and differences do not reflect formatting changes.

## Linter-styler conflicts

There are cases in which the linters and stylers do not always agree.
This is natural as they are released by different projects: _clang-format_ by LLVM, and _cpplint_ derives from Google's work.

One example is the use of `BOOST_FOREACH` as an alternative to `for` loops.
_clang-format_ will insist on adding two spaces before the opening bracket: `BOOST_FOREACH  ()`.
_cpplint_ will insist on removing one space.
_cpplint_ and _clang-format_ also disagree on the order of header inclusions, especially when both local and system headers are included.

Choosing one over the other requires disabling checks on some part of the code.
It is possible to turn off linting using _cpplint_ at particular lines using the comment `// NOLINT`.
Multiple lines can be protected from linting as well.

```c++
// NOLINTBEGIN
<some C++ code here>
// NOLINTEND
```

Alternatively, _clang-format_ can be instructed to ignore chunks of code using comment messages too.

```c++
// clang-format off
<some C++ code here>
// clang-format on
```

## Linter options for future packages

{finalsize} is a relatively simple {Rcpp} package, with no C/C++ headers, and no C++ tests.
However, future Epiverse packages could be more similar to {fluEvidenceSynthesis}, and will have header files, and could also have [C++ unit tests via the _catch_ framework](https://github.com/catchorg/Catch2).

_cpplint_ will demand that all local headers be prefixed with their directory (`src/`), but this would cause the code to break as {Rcpp} looks for a subdirectory called `src/src/`.
This can be turned off by passing the filter option `--filter="-build/include_subdir"` to _cpplint_. 
Alternatively, we can place headers in a subdirectory such as `inst/include`.

Both _cpplint_ and _cppcheck_ can be instructed to ignore C++ test files using the _catch_ testing framework provided by {testthat}.
This prevents errors due to the specialised syntax provided by {testthat} in `testthat.h`, such as `context`.

```sh
# for cpplint, add an extra exclude statement
cpplint <...> --exclude="src/test*.cpp" src/*.cpp

# for cppcheck, suppress checks on test files
cppcheck <...> --suppress=*:src/test_*.cpp src
```

## Conclusion

It is actually somewhat surprising that there does not seem to be a canonical linter for C++ code in {Rcpp} packages.
The methods laid out here are an initial implementation developed for use with the {finalsize} package, and the considerations here are a starting point.
We shall be continuously evaluating how we ensure the quality of our C++ code as we encounter more use cases while developing future Epiverse packages.
