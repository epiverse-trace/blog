---
title: "Sharing the C++ Code of an Rcpp Package"
author:
  - name: "Pratik Gupte"
    orcid: "0000-0001-5294-7819"
date: "2023-04-24"
categories: [code sharing, R, R package, Rcpp, interoperability]
format:
  html:
    toc: true
---

## Use case

Using the [{Rcpp}](https://www.rcpp.org/) package is the dominant method for linking a perfomant, low-level language (C++) with R --- this combines the usability of R with the speed of C++, and can be used to write R packages that are both fast and easy to use for both end-users and developers.

From the point of view of developers, it's very easy to export R code such as functions and classes from an R(cpp) package, but there is little clear guidance on how to export the C++ code so that it can be shared with your other Rcpp packages.

Allowing C++ code to be shared can be very beneficial for the same reasons that sharing R code is --- packaging code is a reliable way to reuse it.
Some widely used examples of this practice are the {RcppEigen}, {RcppArmadillo}, {RcppGSL}, and Boost Headers {BH} packages.
Indeed, in the Epiverse-TRACE team, {RcppEigen} underpins the {finalsize} and upcoming {epidemics} packages.

## Two ways to share C++ code?

Developers searching for a way to make the C++ code of their Rcpp-based packages shareable will likely find two seemingly distinct ways of doing so.
Developers reading the Rcpp Attributes documentation will find that package C++ code can be shared by generating a C++ interface for functions that also have an R interface, [using Rcpp attributes](https://dirk.eddelbuettel.com/code/rcpp/Rcpp-attributes.pdf).
Developers instead scanning widely used Rcpp packages such as {RcppEigen} will notice that C++ code can also be shared by defining the majority of the C++ functions in a package header, to which other Rcpp packages can be linked.

These 'two' methods are actually different pathways to the writing and export of an R(cpp) package header.
This blog post explores the two methods, and explains how the Rcpp packages from Epiverse-TRACE implement C++ code sharing.

## The package header

The package header of the package `{mypackage}` is a file of the name `mypackage.h` under `inst/include`.
Defining this header is the key step in making (R)C++ code shareable.
You'll also need to make this 

```sh
# conceptual organisation of an Rcpp package with a package header
.
├── DESCRIPTION
├── NAMESPACE
├── R
│   ├── RcppExports.R
│   └── mypackage-package.R
├── inst
│   └── include
│       ├── mypackage.h       # <= the package header
│       └── hello.h           # <= we'll return to this
└── src
    ├── RcppExports.cpp
    └── rcpp_hello.cpp        # <= code from which RcppExports.cpp generates
```

## Autogenerating the package header

## Defining the package header manually

## Contents of the package header

There are few to no documented rules around the content of the package header.
Autogenerated package headers contain a autogeneration message and a generator token, similar to that present in `RcppExports` files (more on autogeneration later).
Package headers should naturally contain a [header include guard](link here WIP).

::: {.callout-tip}
**Styling the header name:**
The style of the header name in the include guard for autogenerated headers is `RCPP_mypackage_H_GEN_`.

Packages from the Rcpp core team, such as {RcppEigen} and {RcppArmadillo}, are manually defined and follow the convention `mypackage__mypackage__h`.

In examples, [such as this bare-bones demonstration package by James Balamuta](https://github.com/coatless-r-n-d/rcpp-shared-cpp-functions), you might also encounter a single underscore (`_`) and a capital `H` (`mypackage_mypackage_H`).

All three are incompatible with Cpplint's preference, which is `DIR_SUBDIR_FILE_H`.
Exclude the package header from linting to avoid this warning if you wish to follow either of the two styles.
:::

Obviously, the package header must also link to the code you want to export, and there are at least three ways of doing this.

1. Directly write C++ code in the package header. This is technically possible, but unlikely to be a good option as your package's C++ codebase grows.
2. Include the autogenerated file `Package_RcppExports.h`; this is already done as part of the package header generation (more on this in a bit).
3. Manually include any other C++ header files WIP

## Extra infor - include in text WIP

<!-- From the docs for Rcpp Attr: If you need to include code from your custom header files within the compilation of your package source files, you will also need to add the following entry to Makevars and Makevars.win (both are in the src directory of your package): `PKG_CPPFLAGS += -I../inst/include/`. Note that the R package build system does not automatically force a rebuild when headers -->
in inst/include change, so you should be

### Extra links - include in text WIP

<!-- https://gallery.rcpp.org/articles/mixing-modules-and-export/ -->

## Conclusion WIP

<!-- Three sentences here. -->
